<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>uncomplicate.neanderthal.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Neanderthal</span> <span class="project-version">0.6.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uncomplicate</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>neanderthal</span></div></div></li><li class="depth-3 branch current"><a href="uncomplicate.neanderthal.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.neanderthal.math.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.neanderthal.native.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>native</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.neanderthal.opencl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>opencl</span></div></a></li><li class="depth-3"><a href="uncomplicate.neanderthal.real.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>real</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-alter.21"><div class="inner"><span>alter!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-asum"><div class="inner"><span>asum</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-ax"><div class="inner"><span>ax</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-axpy"><div class="inner"><span>axpy</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-axpy.21"><div class="inner"><span>axpy!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-col"><div class="inner"><span>col</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-cols"><div class="inner"><span>cols</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-compatible.3F"><div class="inner"><span>compatible?</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-copy"><div class="inner"><span>copy</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-copy.21"><div class="inner"><span>copy!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-create"><div class="inner"><span>create</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-create-ge-matrix"><div class="inner"><span>create-ge-matrix</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-create-raw"><div class="inner"><span>create-raw</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-create-vector"><div class="inner"><span>create-vector</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-dim"><div class="inner"><span>dim</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-dot"><div class="inner"><span>dot</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-ecount"><div class="inner"><span>ecount</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-entry"><div class="inner"><span>entry</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-entry.21"><div class="inner"><span>entry!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-iamax"><div class="inner"><span>iamax</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-imax"><div class="inner"><span>imax</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-imin"><div class="inner"><span>imin</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-matrix.3F"><div class="inner"><span>matrix?</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mm"><div class="inner"><span>mm</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mm.21"><div class="inner"><span>mm!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mrows"><div class="inner"><span>mrows</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mv"><div class="inner"><span>mv</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mv.21"><div class="inner"><span>mv!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-ncols"><div class="inner"><span>ncols</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-nrm2"><div class="inner"><span>nrm2</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rank"><div class="inner"><span>rank</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rank.21"><div class="inner"><span>rank!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-raw"><div class="inner"><span>raw</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rot.21"><div class="inner"><span>rot!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rotg.21"><div class="inner"><span>rotg!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rotm.21"><div class="inner"><span>rotm!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rotmg.21"><div class="inner"><span>rotmg!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-row"><div class="inner"><span>row</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rows"><div class="inner"><span>rows</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-scal.21"><div class="inner"><span>scal!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-submatrix"><div class="inner"><span>submatrix</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-subvector"><div class="inner"><span>subvector</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-sum"><div class="inner"><span>sum</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-swp.21"><div class="inner"><span>swp!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-trans"><div class="inner"><span>trans</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-transfer"><div class="inner"><span>transfer</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-transfer.21"><div class="inner"><span>transfer!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-vect.3F"><div class="inner"><span>vect?</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-xpy"><div class="inner"><span>xpy</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-zero"><div class="inner"><span>zero</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">uncomplicate.neanderthal.core</h1><div class="doc"><pre class="plaintext">Contains type-agnostic linear algebraic functions. Typically,
you would want to require this namespace regardless of the actual type
(real, complex, CPU, GPU, pure Java etc.) of the vectors and matrices that
you use.

In cases when you need to repeatedly call a function from this namespace
that accesses individual entries, and the entries are primitive, it
is better to use a primitive version of the function from
uncomplicate.neanderthal.core namespace.
Additionally, constructor functions for different kinds of vectors
(native, GPU, pure java) are in respective specialized namespaces.

You need to take care to only use vectors and matrices
of the same type in the same function call. These functions do not support
arguments of mixed types. For example, you can not call the
dot function with one double vector (dv) and one float vector (fv),
or for one vector in the CPU memory and one in the GPU memory.

## Examples

(ns test
  (:require [uncomplicate.neanderthal core native]))

(ns test
  (:require [uncomplicate.neanderthal core native opencl]))
</pre></div><div class="public anchor" id="var-alter.21"><h3>alter!</h3><div class="usage"><code>(alter! v i f)</code><code>(alter! m i j f)</code></div><div class="doc"><pre class="plaintext">Alters the i-th entry of vector x, or ij-th entry of matrix m, to te result
of applying a function f to the old value at that position, and returns the
updated container.

In case  your container holds primitive elements, the function f
must accept appropriate primitive unboxed arguments, and it will work faster
if it also returns unboxed result.

(alter! (dv 1 2 3) 2 (fn ^double [^double x] (inc x)))
#&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 4.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-asum"><h3>asum</h3><div class="usage"><code>(asum x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Sum absolute values.
Sums absolute values of entries of vector x.

(asum (dv -1 2 -3)) =&gt; 6.0
</pre></div></div><div class="public anchor" id="var-ax"><h3>ax</h3><div class="usage"><code>(ax alpha x)</code></div><div class="doc"><pre class="plaintext">Multiplies container x by a scalar a.
Similar to scal!, but does not change x. The result
is a new vector instance.</pre></div></div><div class="public anchor" id="var-axpy"><h3>axpy</h3><div class="usage"><code>(axpy x y)</code><code>(axpy x y z)</code><code>(axpy x y z w &amp; ws)</code></div><div class="doc"><pre class="plaintext">A pure variant of axpy! that does not change any of the arguments.
The result is a new instance.
</pre></div></div><div class="public anchor" id="var-axpy.21"><h3>axpy!</h3><div class="usage"><code>(axpy! alpha x y)</code><code>(axpy! x y)</code><code>(axpy! x y z &amp; zs)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Vector scale and add. Also works on matrices.

Computes y = ax + y.
where:
x and y are vectors, or matrices
a is a scalar.

Multiplies vector x by scalar alpha and adds it to
vector y. After axpy!, y will be changed.

If called with 2 arguments, x and y, adds vector x
to vector y.

If called with more than 3 arguments, at least every
other have to be a vector. A scalar multiplier may be
included before each vector.

If the dimensions of x and y are not compatible,
throws IllegalArgumentException.

(def x (dv 1 2 3))
(def y (dv 2 3 4))
(axpy! 1.5 x y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(3.5 6.0 8.5)&lt;&gt;

y =&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(3.5 6.0 8.5)&lt;&gt;

(axpy! x y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(4.5 8.0 11.5)&lt;&gt;

(axpy! x y (dv 3 4 5) 2 (dv 1 2 3))
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(10.5 18.0 25.5)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-col"><h3>col</h3><div class="usage"><code>(col m j)</code></div><div class="doc"><pre class="plaintext">Returns the j-th column of the matrix m as a vector.

The resulting vector has a live connection to the
matrix data. Any change to the vector data will affect
the matrix data.
If you wish to disconnect the vector from the parent
matrix, make a copy of the vector (copy x) prior
to any changing operation.

(col (dge 3 2 [1 2 3 4 5 6]) 0)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-cols"><h3>cols</h3><div class="usage"><code>(cols m)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of vectors that represent
columns of the matrix m.
These vectors have a live connection to the matrix data.
</pre></div></div><div class="public anchor" id="var-compatible.3F"><h3>compatible?</h3><div class="usage"><code>(compatible? x y)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-copy"><h3>copy</h3><div class="usage"><code>(copy x)</code><code>(copy x offset length)</code></div><div class="doc"><pre class="plaintext">Returns a new copy the (part of) entries from container x.
Changes to the resulting vectors do not affect x.

(copy (dv 1 2 3))
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-copy.21"><h3>copy!</h3><div class="usage"><code>(copy! x y)</code><code>(copy! x y offset-x length offset-y)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Copy a vector or a matrice.
Copies the entries of x into y and returns x. x and y must have
equal dimensions. y will be changed. Also works on
matrices.

If provided with length, offset-x, and offset-y, copies a subvector
of x into a subvector of y, if there is enough space in y.

If x and y are not compatible, throws IllegalArgumentException.

(def x (dv 1 2 3))
(def y (dv 3 4 5))
(copy! x y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
y
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-create"><h3>create</h3><div class="usage"><code>(create factory n)</code><code>(create factory m n)</code></div><div class="doc"><pre class="plaintext">Creates an initialized vector of the dimension n, or a  matrix m x n,
using the provided factory.
More specific methods are available in technology-specific namespaces.

See uncomplicate.neanderthal.native, uncomplicate.neanderthal.opencl, etc.

(create cblas-single 3)
(create cblas-double 35 12)</pre></div></div><div class="public anchor" id="var-create-ge-matrix"><h3>create-ge-matrix</h3><div class="usage"><code>(create-ge-matrix factory m n source)</code><code>(create-ge-matrix factory m n)</code></div><div class="doc"><pre class="plaintext">Creates a dense, column-oriented mxn matrix from source.

If called with two arguments, creates a zero matrix with dimensions mxn.

Accepts the following sources:
- java.nio.ByteBuffer with a capacity = elementWidth * m * n,
. which will be used as-is for backing the matrix.
- a clojure sequence, which will be copied into a
. direct ByteBuffer that backs the new vector.

(create-ge-matrix *double-factory* 15 13)
</pre></div></div><div class="public anchor" id="var-create-raw"><h3>create-raw</h3><div class="usage"><code>(create-raw factory n)</code><code>(create-raw factory m n)</code></div><div class="doc"><pre class="plaintext">Creates an uninitialized vector of the dimension n, or a  matrix m x n,
using the provided factory. It might or might not be initialized to zeroes,
depending of the underlying memory (DirectBytebuffer is zero-initialized,
OpenCL CLBuffer contains random junk). If you need to be sure that the
new object is filled with zeros, consider using the create function.

More specific methods are available in technology-specific namespaces.

See uncomplicate.neanderthal.native, uncomplicate.neanderthal.opencl, etc.

(create-raw cblas-single 3)
(create-raw cblas-double 35 12)</pre></div></div><div class="public anchor" id="var-create-vector"><h3>create-vector</h3><div class="usage"><code>(create-vector factory source)</code><code>(create-vector factory x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Creates a vector from source using the provided factory.

Accepts the following source:
- java.nio.ByteBuffer with a capacity divisible by the element width,
. which will be used as-is for backing the vector.
- a positive integer, which will be used as a dimension
. of new vector with zeroes as entries.
- a floating point number, which will be the only entry
. in a one-dimensional vector.
- a clojure sequence, which will be copied into a
. direct ByteBuffer that backs the new vector.
- varargs will be treated as a clojure sequence.

(create-vector *double-factory* [1 2 3])
(create-vector *single-factory* 12)
</pre></div></div><div class="public anchor" id="var-dim"><h3>dim</h3><div class="usage"><code>(dim x)</code></div><div class="doc"><pre class="plaintext">Returns the dimension of the vector x.

(dim (dv 1 2 3) =&gt; 3)
</pre></div></div><div class="public anchor" id="var-dot"><h3>dot</h3><div class="usage"><code>(dot x y)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Dot product.
Computes the dot product of vectors x and y.

(dot (dv 1 2 3) (dv 1 2 3)) =&gt; 14.0
</pre></div></div><div class="public anchor" id="var-ecount"><h3>ecount</h3><div class="usage"><code>(ecount x)</code></div><div class="doc"><pre class="plaintext">Returns the total number of elements in all dimensions of a block x
of (possibly strided) memory.

(ecount (dv 1 2 3)) =&gt; 3
(ecount (dge 2 3)) =&gt; 6
</pre></div></div><div class="public anchor" id="var-entry"><h3>entry</h3><div class="usage"><code>(entry x i)</code><code>(entry m i j)</code></div><div class="doc"><pre class="plaintext">Returns the BOXED i-th entry of vector x, or ij-th entry of matrix m.
In case  your container holds primitive elements, or the element have
a specific structure, it is much better to use the equivalent methods from
function from uncomplicate.neanderthal.real.

(entry (dv 1 2 3) 1) =&gt; 2.0
</pre></div></div><div class="public anchor" id="var-entry.21"><h3>entry!</h3><div class="usage"><code>(entry! c val)</code><code>(entry! v i val)</code><code>(entry! m i j val)</code></div><div class="doc"><pre class="plaintext">Sets the i-th entry of vector x, or ij-th entry of matrix m,
or all entries if no index is provided, to BOXED value val and returns
the updated container.
In case  your container holds primitive elements, or the element have
a specific structure, it is much better to use the equivalent methods from
function from uncomplicate.neanderthal.real.

(entry! (dv 1 2 3) 2 -5)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 -5.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-iamax"><h3>iamax</h3><div class="usage"><code>(iamax x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: The index of the largest absolute value.
The index of the first entry that has the maximum value.

(iamax (dv 1 -3 2)) =&gt; 1
</pre></div></div><div class="public anchor" id="var-imax"><h3>imax</h3><div class="usage"><code>(imax x)</code></div><div class="doc"><pre class="plaintext">BLAS 1+: The index of the largest value.
The index of the first entry that has the maximum value.

(imax (dv 1 -3 2)) =&gt; 2
</pre></div></div><div class="public anchor" id="var-imin"><h3>imin</h3><div class="usage"><code>(imin x)</code></div><div class="doc"><pre class="plaintext">BLAS 1+: The index of the smallest value.
The index of the first entry that has the minimum value.

(imin (dv 1 -3 2)) =&gt; 2
</pre></div></div><div class="public anchor" id="var-matrix.3F"><h3>matrix?</h3><div class="usage"><code>(matrix? x)</code></div><div class="doc"><pre class="plaintext">Returns true if x implements uncomplicate.neanderthal.protocols.Matrix.

(matrix? (dge 3 2 [1 2 3 4 5 6])) =&gt; true
(matrix? [[1 2] [3 4] [5 6]]) =&gt; false
</pre></div></div><div class="public anchor" id="var-mm"><h3>mm</h3><div class="usage"><code>(mm alpha a b)</code><code>(mm a b)</code></div><div class="doc"><pre class="plaintext">A pure version of mm!, that returns the result
in a new matrix instance.
Computes alpha a * b</pre></div></div><div class="public anchor" id="var-mm.21"><h3>mm!</h3><div class="usage"><code>(mm! alpha a b beta c)</code><code>(mm! a b c)</code><code>(mm! alpha a b c)</code></div><div class="doc"><pre class="plaintext">BLAS 3: Matrix-matrix multiplication.

Computes c = alpha a * b + beta * c
where:
a, b and c are matrices,
alpha and beta are scalars.

Multiplies matrix a by scalar alpha and then multiplies
the resulting matrix by matrix b. Adds the resulting
matrix to matrix c previously scaled by scalar beta.
Returns matrix c, which contains the result and is changed by
the operation.

Can be called without scalars, with three matrix arguments.

If the dimensions of a, b and c are not compatible,
throws IllegalArgumentException.

(def a (dge 2 3 (range 6)))
(def b (dge 3 2 (range 2 8)))
(def c (dge 2 2 [1 1 1 1]))

(mm! 1.5 a b 2.5 c)
=&gt; #&lt;GeneralMatrix| double, COL, mxn: 2x2, ld:2&gt;((35.5 49.0) (62.5 89.5))&lt;&gt;

(def c (dge 2 2))
(mm! a b c)
=&gt; #&lt;GeneralMatrix| double, COL, mxn: 2x2, ld:2&gt;((22.0 31.0) (40.0 58.0))&lt;&gt;
</pre></div></div><div class="public anchor" id="var-mrows"><h3>mrows</h3><div class="usage"><code>(mrows m)</code></div><div class="doc"><pre class="plaintext">Returns the number of rows of the matrix m.

(mrows (dge 3 2 [1 2 3 4 5 6])) =&gt; 3
</pre></div></div><div class="public anchor" id="var-mv"><h3>mv</h3><div class="usage"><code>(mv alpha a x)</code><code>(mv a x)</code></div><div class="doc"><pre class="plaintext">A pure version of mv! that returns the result
in a new vector instance. Computes alpha a * x.</pre></div></div><div class="public anchor" id="var-mv.21"><h3>mv!</h3><div class="usage"><code>(mv! alpha a x beta y)</code><code>(mv! alpha a x y)</code><code>(mv! a x y)</code></div><div class="doc"><pre class="plaintext">BLAS 2: Matrix-vector multiplication.

Computes y = alpha a * x + beta * y
where:
a is a matrix,
x and y are vectors,
alpha and beta are scalars.

Multiplies the matrix a by the scalar alpha and then multiplies
the resulting matrix by the vector x. Adds the resulting
vector to the vector y, previously scaled by the scalar beta.
Returns the vector y, which contains the result and is changed by
the operation.

If alpha and beta are not provided, uses identity value as their values.

If the dimensions of a, x and y are not compatible,
throws IllegalArgumentException.

(def a (dge 3 2 (range 6)))
(def x (dv 1 2))
(def y (dv 2 3 4))

(mv! 2.0 a x 1.5 y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(15.0 22.5 30.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-ncols"><h3>ncols</h3><div class="usage"><code>(ncols m)</code></div><div class="doc"><pre class="plaintext">Returns the number of columns of the matrix m.
(mrows (dge 3 2 [1 2 3 4 5 6])) =&gt; 2
</pre></div></div><div class="public anchor" id="var-nrm2"><h3>nrm2</h3><div class="usage"><code>(nrm2 x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Euclidean norm.
Computes the Euclidan (L2) norm of vector x.

(nrm2 (dv 1 2 3)) =&gt; 3.7416573867739413
</pre></div></div><div class="public anchor" id="var-rank"><h3>rank</h3><div class="usage"><code>(rank alpha x y)</code><code>(rank x y)</code></div><div class="doc"><pre class="plaintext">A pure version of rank! that returns the result
in a new matrix instance.
</pre></div></div><div class="public anchor" id="var-rank.21"><h3>rank!</h3><div class="usage"><code>(rank! alpha x y a)</code><code>(rank! x y a)</code></div><div class="doc"><pre class="plaintext">BLAS 2: General rank-1 update.

Computes a = alpha * x * y' + a
where:

alpha is a scalar
x and y are vectors, y' is a transposed vector,
a is a mxn matrix.

If called with 3 arguments, a, x, y, alpha is 1.0.

(def a (dge 3 2 [1 1 1 1 1 1]))
(rank! 1.5 (dv 1 2 3) (dv 4 5) a)
=&gt; #&lt;GeneralMatrix| double, COL, mxn: 3x2, ld:3&gt;((7.0 13.0 19.0) (8.5 16.0 23.5))&lt;&gt;
</pre></div></div><div class="public anchor" id="var-raw"><h3>raw</h3><div class="usage"><code>(raw x)</code><code>(raw factory x)</code></div><div class="doc"><pre class="plaintext">Returns an uninitialized instance of the same type and dimension(s)
as x, which can be neanderthal container.</pre></div></div><div class="public anchor" id="var-rot.21"><h3>rot!</h3><div class="usage"><code>(rot! x y c s)</code><code>(rot! x y c)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Apply plane rotation.
</pre></div></div><div class="public anchor" id="var-rotg.21"><h3>rotg!</h3><div class="usage"><code>(rotg! x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Generate plane rotation.

# Description:

Computes  the  elements  of  a Givens plane rotation matrix:
.           __    __     __ __    __ __
.           | c  s |     | a |    | r |
.           |-s  c | *   | b | =  | 0 |
.           --    --     -- --    -- --

where  r = +- sqrt ( a**2 + b**2 )
and    c**2 + s**2 = 1.

a, b, c, s are the four entries in the vector x.

This rotation can be used to selectively introduce zero elements
into a matrix.

# Arguments:

x: contains a, b, c, and s arguments (see the description).
.  Has to have exactly these four entries, and must have stride = 1.

# Result:

x with the elements changed to be r, z, c, s.
For a detailed description see
<a href="http://www.mathkeisan.com/usersguide/man/drotg.html">http://www.mathkeisan.com/usersguide/man/drotg.html</a>
</pre></div></div><div class="public anchor" id="var-rotm.21"><h3>rotm!</h3><div class="usage"><code>(rotm! x y p)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Apply modified plane rotation.
</pre></div></div><div class="public anchor" id="var-rotmg.21"><h3>rotmg!</h3><div class="usage"><code>(rotmg! p args)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Generate modified plane rotation.
- p must be a vector of exactly 5 entries
- args must be a vector of exactly 4 entries
</pre></div></div><div class="public anchor" id="var-row"><h3>row</h3><div class="usage"><code>(row m i)</code></div><div class="doc"><pre class="plaintext">Returns the i-th row of the matrix m as a vector.

The resulting vector has a live connection to the
matrix data. Any change to the vector data will affect
the matrix data.
If you wish to disconnect the vector from the parent
matrix, make a copy of the vector (copy x) prior
to any changing operation.

(row (dge 3 2 [1 2 3 4 5 6]) 1)
=&gt; #&lt;RealBlockVector| double, n:2, stride:3&gt;(2.0 5.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-rows"><h3>rows</h3><div class="usage"><code>(rows m)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of vectors that represent
rows of the matrix m.
These vectors have a live connection to the matrix data.
</pre></div></div><div class="public anchor" id="var-scal.21"><h3>scal!</h3><div class="usage"><code>(scal! alpha x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Scale vector.

Computes x = ax
where:
- x is a vector,
- a is a scalar.

Multiplies vector x by scalar alpha, i.e scales the vector.
After scal!, x will be changed.

(scal! 1.5  (dv 1 2 3))
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.5 3.0 4.5)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-submatrix"><h3>submatrix</h3><div class="usage"><code>(submatrix a i j k l)</code><code>(submatrix a k l)</code></div><div class="doc"><pre class="plaintext">Returns a submatrix of m starting with row i, column j,
that has k columns and l rows.

The resulting submatrix has a live connection to the
matrix m's data. Any change to the submatrix data will affect
m's data.
If you wish to disconnect the submatrix from the parent
matrix, make a copy of the submatrix (copy subm) prior
to any changing operation.

(submatrix (dge 4 3 (range 12)) 1 1 2 1)
=&gt; #&lt;GeneralMatrix| double, COL, mxn: 2x1, ld:4&gt;((5.0 6.0))&lt;&gt;
</pre></div></div><div class="public anchor" id="var-subvector"><h3>subvector</h3><div class="usage"><code>(subvector x k l)</code></div><div class="doc"><pre class="plaintext">Returns a subvector starting witk k, l entries long,
which is a part of a neanderthal vector x.

The resulting subvector has a live connection to the
vector data. Any change to the subvector data will affect
the vector data.
If you wish to disconnect the subvector from the parent
vector, make a copy of the subvector (copy subx) prior
to any destructive operation.

(subvector (dv 1 2 3 4 5 6) 2 3)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(3.0 4.0 5.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-sum"><h3>sum</h3><div class="usage"><code>(sum x)</code></div><div class="doc"><pre class="plaintext">Sums values of entries of x.

(sum (dv -1 2 -3)) =&gt; -2.0
</pre></div></div><div class="public anchor" id="var-swp.21"><h3>swp!</h3><div class="usage"><code>(swp! x y)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Swap vectors or matrices.
Swaps the entries of containers x and y. x and y must have
equal dimensions. Both x and y will be changed.
Works on both vectors and matrices.

If the dimensions of x and y are not compatible,
throws IllegalArgumentException.

(def x (dv 1 2 3))
(def y (dv 3 4 5))
(swp! x y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(3.0 4.0 5.0)&lt;&gt;
y
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
</pre></div></div><div class="public anchor" id="var-trans"><h3>trans</h3><div class="usage"><code>(trans m)</code></div><div class="doc"><pre class="plaintext">Transposes matrix m, i.e returns a matrix that has
m's columns as rows.
The resulting matrix has a live connection to m's data.

(trans (dge 3 2 [1 2 3 4 5 6]))
=&gt; #&lt;GeneralMatrix| double, ROW, mxn: 2x3, ld:3&gt;((1.0 2.0 3.0) (4.0 5.0 6.0))&lt;&gt;
</pre></div></div><div class="public anchor" id="var-transfer"><h3>transfer</h3><div class="usage"><code>(transfer factory x)</code><code>(transfer x)</code></div><div class="doc"><pre class="plaintext">Transfers the data to the memory space defined by factory (OpenCL, CUDA, etc.).
If the factory is not provided, moves the data to the main host memory.
If x is already in the main memory, makes a fresh copy.

(transfer (sv [1 2 3]) opencl-factory)
(transfer (sge 2 3 (range 6)) opencl-factory)

(transfer (sv [1 2 3]))
</pre></div></div><div class="public anchor" id="var-transfer.21"><h3>transfer!</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Transfers the data from source in one type of memory, to the appropriate
destination in another type of memory. Typically you would use it when you want to
move data between the host memory and the OpenCL device memory. If you want to
simply move data from one container to another in the same memory space,
you should use copy.  If you call transfer in one memory space, it would simply
be copied.

(transfer! (sv 1 2 3) device-vect)
(transfer! device-vect (sv 3))
</pre></div></div><div class="public anchor" id="var-vect.3F"><h3>vect?</h3><div class="usage"><code>(vect? x)</code></div><div class="doc"><pre class="plaintext">Returns true if x implements uncomplicate.neanderthal.protocols.Vector.

(vect? (dv 1 2 3)) =&gt; true
(vect? [1 2 3]) =&gt; false
</pre></div></div><div class="public anchor" id="var-xpy"><h3>xpy</h3><div class="usage"><code>(xpy x y)</code><code>(xpy x y &amp; zs)</code></div><div class="doc"><pre class="plaintext">Sums containers x, y &amp; zs. The result is a new vector instance.
</pre></div></div><div class="public anchor" id="var-zero"><h3>zero</h3><div class="usage"><code>(zero x)</code><code>(zero factory x)</code></div><div class="doc"><pre class="plaintext">Returns an instance of the same type and dimension(s) as the container x,
filled with 0.</pre></div></div></div></body></html>