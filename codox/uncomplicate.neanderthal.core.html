<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>uncomplicate.neanderthal.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Neanderthal 0.3.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uncomplicate</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>neanderthal</span></div></div></li><li class="depth-3 branch current"><a href="uncomplicate.neanderthal.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.neanderthal.math.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.neanderthal.native.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>native</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.neanderthal.opencl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>opencl</span></div></a></li><li class="depth-3"><a href="uncomplicate.neanderthal.real.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>real</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-alter.21"><div class="inner"><span>alter!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-asum"><div class="inner"><span>asum</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-ax"><div class="inner"><span>ax</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-axpy"><div class="inner"><span>axpy</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-axpy.21"><div class="inner"><span>axpy!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-col"><div class="inner"><span>col</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-cols"><div class="inner"><span>cols</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-copy"><div class="inner"><span>copy</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-copy.21"><div class="inner"><span>copy!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-dim"><div class="inner"><span>dim</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-dot"><div class="inner"><span>dot</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-ecount"><div class="inner"><span>ecount</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-entry"><div class="inner"><span>entry</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-entry.21"><div class="inner"><span>entry!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-fmap.21"><div class="inner"><span>fmap!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-fold"><div class="inner"><span>fold</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-freduce"><div class="inner"><span>freduce</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-iamax"><div class="inner"><span>iamax</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-matrix.3F"><div class="inner"><span>matrix?</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mm"><div class="inner"><span>mm</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mm.21"><div class="inner"><span>mm!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mrows"><div class="inner"><span>mrows</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mv"><div class="inner"><span>mv</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-mv.21"><div class="inner"><span>mv!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-ncols"><div class="inner"><span>ncols</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-nrm2"><div class="inner"><span>nrm2</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rank"><div class="inner"><span>rank</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rank.21"><div class="inner"><span>rank!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rot.21"><div class="inner"><span>rot!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rotg.21"><div class="inner"><span>rotg!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rotm.21"><div class="inner"><span>rotm!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rotmg.21"><div class="inner"><span>rotmg!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-row"><div class="inner"><span>row</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-rows"><div class="inner"><span>rows</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-scal.21"><div class="inner"><span>scal!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-submatrix"><div class="inner"><span>submatrix</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-subvector"><div class="inner"><span>subvector</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-sum"><div class="inner"><span>sum</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-swp.21"><div class="inner"><span>swp!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-trans"><div class="inner"><span>trans</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-vect.3F"><div class="inner"><span>vect?</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-xpy"><div class="inner"><span>xpy</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.core.html#var-zero"><div class="inner"><span>zero</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">uncomplicate.neanderthal.core</h2><div class="doc"><pre class="plaintext">Contains type-agnostic linear algebraic functions. Typically,
you would want to require this namespace regardless of the actual type
(real, complex, CPU, GPU, pure Java etc.) of the vectors and matrices that
you use.

In cases when you need to repeatedly call a function from this namespace
that accesses individual entries, and the entries are primitive, it
is better to use a primitive version of the function from
uncomplicate.neanderthal.core namespace.
Additionally, constructor functions for different kinds of vectors
(native, GPU, pure java) are in respective specialized namespaces.

You need to take care to only use vectors and matrices
of the same type in the same function call. These functions do not support
arguments of mixed types. For example, you can not call the
dot function with one double vector (dv) and one float vector (fv),
or for one vector in the CPU memory and one in the GPU memory.

## Examples

(ns test
  (:require [uncomplicate.neanderthal core native]))

(ns test
  (:require [uncomplicate.neanderthal core native opencl]))
</pre></div><div class="public anchor" id="var-alter.21"><h3>alter!</h3><div class="usage"><code>(alter! v i f)</code><code>(alter! m i j f)</code></div><div class="doc"><pre class="plaintext">Alters the i-th entry of vector x, or ij-th entry of matrix m, to te result
of applying a function f to the old value at that position, and returns the
updated container.

In case  your container holds primitive elements, the function f
must accept appropriate primitive unboxed arguments, and it will work faster
if it also returns unboxed result.

(alter! (dv 1 2 3) 2 (fn ^double [^double x] (inc x)))
#&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 4.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L301">view source</a></div></div><div class="public anchor" id="var-asum"><h3>asum</h3><div class="usage"><code>(asum x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Sum absolute values.
Sums absolute values of entries of vector x.

(asum (dv -1 2 -3)) =&gt; 6.0
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L343">view source</a></div></div><div class="public anchor" id="var-ax"><h3>ax</h3><div class="usage"><code>(ax alpha x)</code></div><div class="doc"><pre class="plaintext">Multiplies container x by a scalar a.
Similar to scal!, but does not change x. The result
is a new vector instance.</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L597">view source</a></div></div><div class="public anchor" id="var-axpy"><h3>axpy</h3><div class="usage"><code>(axpy x y)</code><code>(axpy alpha x y)</code><code>(axpy x y z w &amp; ws)</code></div><div class="doc"><pre class="plaintext">A pure variant of axpy! that does not change any of the arguments.
The result is a new instance.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L584">view source</a></div></div><div class="public anchor" id="var-axpy.21"><h3>axpy!</h3><div class="usage"><code>(axpy! alpha x y)</code><code>(axpy! x y)</code><code>(axpy! x y z &amp; zs)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Vector scale and add. Also works on matrices.

Computes y = ax + y.
where:
x and y are vectors, or matrices
a is a scalar.

Multiplies vector x by scalar alpha and adds it to
vector y. After axpy!, y will be changed.

If called with 2 arguments, x and y, adds vector x
to vector y.

If called with more than 3 arguments, at least every
other have to be a vector. A scalar multiplier may be
included before each vector.

If the dimensions of x and y are not compatible,
throws IllegalArgumentException.

(def x (dv 1 2 3))
(def y (dv 2 3 4))
(axpy! 1.5 x y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(3.5 6.0 8.5)&lt;&gt;

y =&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(3.5 6.0 8.5)&lt;&gt;

(axpy! x y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(4.5 8.0 11.5)&lt;&gt;

(axpy! x y (dv 3 4 5) 2 (dv 1 2 3))
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(10.5 18.0 25.5)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L531">view source</a></div></div><div class="public anchor" id="var-col"><h3>col</h3><div class="usage"><code>(col m j)</code></div><div class="doc"><pre class="plaintext">Returns the j-th column of the matrix m as a vector.

The resulting vector has a live connection to the
matrix data. Any change to the vector data will affect
the matrix data.
If you wish to disconnect the vector from the parent
matrix, make a copy of the vector (copy x) prior
to any changing operation.

(col (dge 3 2 [1 2 3 4 5 6]) 0)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L192">view source</a></div></div><div class="public anchor" id="var-cols"><h3>cols</h3><div class="usage"><code>(cols m)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of vectors that represent
columns of the matrix m.
These vectors have a live connection to the matrix data.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L211">view source</a></div></div><div class="public anchor" id="var-copy"><h3>copy</h3><div class="usage"><code>(copy x)</code></div><div class="doc"><pre class="plaintext">Returns a new copy the entries from container x.
Changes to the resulting vectors do not affect x.

(copy (dv 1 2 3))
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L519">view source</a></div></div><div class="public anchor" id="var-copy.21"><h3>copy!</h3><div class="usage"><code>(copy! x y)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Copy a vector or a matrice.
Copies the entries of x into y and returns x. x and y must have
equal dimensions. y will be changed. Also works on
matrices.

If the dimensions of x and y are not compatible,
throws IllegalArgumentException.

(def x (dv 1 2 3))
(def y (dv 3 4 5))
(copy! x y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
y
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L493">view source</a></div></div><div class="public anchor" id="var-dim"><h3>dim</h3><div class="usage"><code>(dim x)</code></div><div class="doc"><pre class="plaintext">Returns the dimension of the vector x.

(dim (dv 1 2 3) =&gt; 3)
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L121">view source</a></div></div><div class="public anchor" id="var-dot"><h3>dot</h3><div class="usage"><code>(dot x y)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Dot product.
Computes the dot product of vectors x and y.

(dot (dv 1 2 3) (dv 1 2 3)) =&gt; 14.0
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L323">view source</a></div></div><div class="public anchor" id="var-ecount"><h3>ecount</h3><div class="usage"><code>(ecount x)</code></div><div class="doc"><pre class="plaintext">Returns the total number of elements in all dimensions of a block x
of (possibly strided) memory.

(ecount (dv 1 2 3)) =&gt; 3
(ecount (dge 2 3)) =&gt; 6
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L129">view source</a></div></div><div class="public anchor" id="var-entry"><h3>entry</h3><div class="usage"><code>(entry x i)</code><code>(entry m i j)</code></div><div class="doc"><pre class="plaintext">Returns the BOXED i-th entry of vector x, or ij-th entry of matrix m.
In case  your container holds primitive elements, or the element have
a specific structure, it is much better to use the equivalent methods from
function from uncomplicate.neanderthal.real.

(entry (dv 1 2 3) 1) =&gt; 2.0
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L264">view source</a></div></div><div class="public anchor" id="var-entry.21"><h3>entry!</h3><div class="usage"><code>(entry! c val)</code><code>(entry! v i val)</code><code>(entry! m i j val)</code></div><div class="doc"><pre class="plaintext">Sets the i-th entry of vector x, or ij-th entry of matrix m,
or all entries if no index is provided, to BOXED value val and returns
the updated container.
In case  your container holds primitive elements, or the element have
a specific structure, it is much better to use the equivalent methods from
function from uncomplicate.neanderthal.real.

(entry! (dv 1 2 3) 2 -5)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 -5.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L280">view source</a></div></div><div class="public anchor" id="var-fmap.21"><h3>fmap!</h3><div class="usage"><code>(fmap! f x)</code><code>(fmap! f x y)</code><code>(fmap! f x y z)</code><code>(fmap! f x y z w)</code><code>(fmap! f x y z w &amp; ws)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L62">view source</a></div></div><div class="public anchor" id="var-fold"><h3>fold</h3><div class="usage"><code>(fold x)</code><code>(fold f x)</code><code>(fold f id x)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L74">view source</a></div></div><div class="public anchor" id="var-freduce"><h3>freduce</h3><div class="usage"><code>(freduce f x)</code><code>(freduce f acc x)</code><code>(freduce f acc x y)</code><code>(freduce f acc x y z)</code><code>(freduce f acc x y z &amp; ws)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L82">view source</a></div></div><div class="public anchor" id="var-iamax"><h3>iamax</h3><div class="usage"><code>(iamax x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: The index of the largest absolute value.
The index of the first entry that has the maximum value.

(iamax (dv 1 3 2)) =&gt; 1
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L352">view source</a></div></div><div class="public anchor" id="var-matrix.3F"><h3>matrix?</h3><div class="usage"><code>(matrix? x)</code></div><div class="doc"><pre class="plaintext">Returns true if x implements uncomplicate.neanderthal.protocols.Matrix.

(matrix? (dge 3 2 [1 2 3 4 5 6])) =&gt; true
(matrix? [[1 2] [3 4] [5 6]]) =&gt; false
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L110">view source</a></div></div><div class="public anchor" id="var-mm"><h3>mm</h3><div class="usage"><code>(mm alpha a b)</code><code>(mm a b)</code></div><div class="doc"><pre class="plaintext">A pure version of mm!, that returns the result
in a new matrix instance.
Computes alpha a * b</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L752">view source</a></div></div><div class="public anchor" id="var-mm.21"><h3>mm!</h3><div class="usage"><code>(mm! alpha a b beta c)</code><code>(mm! a b c)</code><code>(mm! alpha a b c)</code></div><div class="doc"><pre class="plaintext">BLAS 3: Matrix-matrix multiplication.

Computes c = alpha a * b + beta * c
where:
a, b and c are matrices,
alpha and beta are scalars.

Multiplies matrix a by scalar alpha and then multiplies
the resulting matrix by matrix b. Adds the resulting
matrix to matrix c previously scaled by scalar beta.
Returns matrix c, which contains the result and is changed by
the operation.

Can be called without scalars, with three matrix arguments.

If the dimensions of a, b and c are not compatible,
throws IllegalArgumentException.

(def a (dge 2 3 (range 6)))
(def b (dge 3 2 (range 2 8)))
(def c (dge 2 2 [1 1 1 1]))

(mm! 1.5 a b 2.5 c)
=&gt; #&lt;GeneralMatrix| double, COL, mxn: 2x2, ld:2&gt;((35.5 49.0) (62.5 89.5))&lt;&gt;

(def c (dge 2 2))
(mm! a b c)
=&gt; #&lt;GeneralMatrix| double, COL, mxn: 2x2, ld:2&gt;((22.0 31.0) (40.0 58.0))&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L702">view source</a></div></div><div class="public anchor" id="var-mrows"><h3>mrows</h3><div class="usage"><code>(mrows m)</code></div><div class="doc"><pre class="plaintext">Returns the number of rows of the matrix m.

(mrows (dge 3 2 [1 2 3 4 5 6])) =&gt; 3
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L158">view source</a></div></div><div class="public anchor" id="var-mv"><h3>mv</h3><div class="usage"><code>(mv alpha a x)</code><code>(mv a x)</code></div><div class="doc"><pre class="plaintext">A pure version of mv! that returns the result
in a new vector instance. Computes alpha a * x.</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L656">view source</a></div></div><div class="public anchor" id="var-mv.21"><h3>mv!</h3><div class="usage"><code>(mv! alpha a x beta y)</code><code>(mv! alpha a x y)</code><code>(mv! a x y)</code></div><div class="doc"><pre class="plaintext">BLAS 2: Matrix-vector multiplication.

Computes y = alpha a * x + beta * y
where:
a is a matrix,
x and y are vectors,
alpha and beta are scalars.

Multiplies the matrix a by the scalar alpha and then multiplies
the resulting matrix by the vector x. Adds the resulting
vector to the vector y, previously scaled by the scalar beta.
Returns the vector y, which contains the result and is changed by
the operation.

If alpha and beta are not provided, uses identity value as their values.

If the dimensions of a, x and y are not compatible,
throws IllegalArgumentException.

(def a (dge 3 2 (range 6)))
(def x (dv 1 2))
(def y (dv 2 3 4))

(mv! 2.0 a x 1.5 y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(15.0 22.5 30.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L616">view source</a></div></div><div class="public anchor" id="var-ncols"><h3>ncols</h3><div class="usage"><code>(ncols m)</code></div><div class="doc"><pre class="plaintext">Returns the number of columns of the matrix m.
(mrows (dge 3 2 [1 2 3 4 5 6])) =&gt; 2
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L166">view source</a></div></div><div class="public anchor" id="var-nrm2"><h3>nrm2</h3><div class="usage"><code>(nrm2 x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Euclidean norm.
Computes the Euclidan (L2) norm of vector x.

(nrm2 (dv 1 2 3)) =&gt; 3.7416573867739413
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L334">view source</a></div></div><div class="public anchor" id="var-rank"><h3>rank</h3><div class="usage"><code>(rank alpha x y)</code><code>(rank x y)</code></div><div class="doc"><pre class="plaintext">A pure version of rank! that returns the result
in a new matrix instance.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L691">view source</a></div></div><div class="public anchor" id="var-rank.21"><h3>rank!</h3><div class="usage"><code>(rank! alpha x y a)</code><code>(rank! x y a)</code></div><div class="doc"><pre class="plaintext">BLAS 2: General rank-1 update.

Computes a = alpha * x * y&apos; + a
where:

alpha is a scalar
x and y are vectors, y&apos; is a transposed vector,
a is a mxn matrix.

If called with 3 arguments, a, x, y, alpha is 1.0.

(def a (dge 3 2 [1 1 1 1 1 1]))
(rank! 1.5 (dv 1 2 3) (dv 4 5) a)
=&gt; #&lt;GeneralMatrix| double, COL, mxn: 3x2, ld:3&gt;((7.0 13.0 19.0) (8.5 16.0 23.5))&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L664">view source</a></div></div><div class="public anchor" id="var-rot.21"><h3>rot!</h3><div class="usage"><code>(rot! x y c s)</code><code>(rot! x y c)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Apply plane rotation.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L380">view source</a></div></div><div class="public anchor" id="var-rotg.21"><h3>rotg!</h3><div class="usage"><code>(rotg! x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Generate plane rotation.

# Description:

Computes  the  elements  of  a Givens plane rotation matrix:
.           __    __     __ __    __ __
.           | c  s |     | a |    | r |
.           |-s  c | *   | b | =  | 0 |
.           --    --     -- --    -- --

where  r = +- sqrt ( a**2 + b**2 )
and    c**2 + s**2 = 1.

a, b, c, s are the four entries in the vector x.

This rotation can be used to selectively introduce zero elements
into a matrix.

# Arguments:

x: contains a, b, c, and s arguments (see the description).
.  Has to have exactly these four entries, and must have stride = 1.

# Result:

x with the elements changed to be r, z, c, s.
For a detailed description see
<a href="http://www.mathkeisan.com/usersguide/man/drotg.html">http://www.mathkeisan.com/usersguide/man/drotg.html</a>
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L395">view source</a></div></div><div class="public anchor" id="var-rotm.21"><h3>rotm!</h3><div class="usage"><code>(rotm! x y p)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Apply modified plane rotation.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L457">view source</a></div></div><div class="public anchor" id="var-rotmg.21"><h3>rotmg!</h3><div class="usage"><code>(rotmg! p args)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Generate modified plane rotation.
- p must be a vector of exactly 5 entries
- args must be a vector of exactly 4 entries
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L438">view source</a></div></div><div class="public anchor" id="var-row"><h3>row</h3><div class="usage"><code>(row m i)</code></div><div class="doc"><pre class="plaintext">Returns the i-th row of the matrix m as a vector.

The resulting vector has a live connection to the
matrix data. Any change to the vector data will affect
the matrix data.
If you wish to disconnect the vector from the parent
matrix, make a copy of the vector (copy x) prior
to any changing operation.

(row (dge 3 2 [1 2 3 4 5 6]) 1)
=&gt; #&lt;RealBlockVector| double, n:2, stride:3&gt;(2.0 5.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L173">view source</a></div></div><div class="public anchor" id="var-rows"><h3>rows</h3><div class="usage"><code>(rows m)</code></div><div class="doc"><pre class="plaintext">Returns a lazy sequence of vectors that represent
rows of the matrix m.
These vectors have a live connection to the matrix data.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L219">view source</a></div></div><div class="public anchor" id="var-scal.21"><h3>scal!</h3><div class="usage"><code>(scal! alpha x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Scale vector.

Computes x = ax
where:
- x is a vector,
- a is a scalar.

Multiplies vector x by scalar alpha, i.e scales the vector.
After scal!, x will be changed.

(scal! 1.5  (dv 1 2 3))
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.5 3.0 4.5)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L361">view source</a></div></div><div class="public anchor" id="var-submatrix"><h3>submatrix</h3><div class="usage"><code>(submatrix a i j k l)</code><code>(submatrix a k l)</code></div><div class="doc"><pre class="plaintext">Returns a submatrix of m starting with row i, column j,
that has k columns and l rows.

The resulting submatrix has a live connection to the
matrix m&apos;s data. Any change to the submatrix data will affect
m&apos;s data.
If you wish to disconnect the submatrix from the parent
matrix, make a copy of the submatrix (copy subm) prior
to any changing operation.

(submatrix (dge 4 3 (range 12)) 1 1 2 1)
=&gt; #&lt;GeneralMatrix| double, COL, mxn: 2x1, ld:4&gt;((5.0 6.0))&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L227">view source</a></div></div><div class="public anchor" id="var-subvector"><h3>subvector</h3><div class="usage"><code>(subvector x k l)</code></div><div class="doc"><pre class="plaintext">Returns a subvector starting witk k, l entries long,
which is a part of a neanderthal vector x.

The resulting subvector has a live connection to the
vector data. Any change to the subvector data will affect
the vector data.
If you wish to disconnect the subvector from the parent
vector, make a copy of the subvector (copy subx) prior
to any destructive operation.

(subvector (dv 1 2 3 4 5 6) 2 3)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(3.0 4.0 5.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L139">view source</a></div></div><div class="public anchor" id="var-sum"><h3>sum</h3><div class="usage"><code>(sum x)</code></div><div class="doc"><pre class="plaintext">Sums values of entries of x.

(sum (dv -1 2 -3)) =&gt; -2.0
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L763">view source</a></div></div><div class="public anchor" id="var-swp.21"><h3>swp!</h3><div class="usage"><code>(swp! x y)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Swap vectors or matrices.
Swaps the entries of containers x and y. x and y must have
equal dimensions. Both x and y will be changed.
Works on both vectors and matrices.

If the dimensions of x and y are not compatible,
throws IllegalArgumentException.

(def x (dv 1 2 3))
(def y (dv 3 4 5))
(swp! x y)
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(3.0 4.0 5.0)&lt;&gt;
y
=&gt; #&lt;RealBlockVector| double, n:3, stride:1&gt;(1.0 2.0 3.0)&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L467">view source</a></div></div><div class="public anchor" id="var-trans"><h3>trans</h3><div class="usage"><code>(trans m)</code></div><div class="doc"><pre class="plaintext">Transposes matrix m, i.e returns a matrix that has
m&apos;s columns as rows.
The resulting matrix has a live connection to m&apos;s data.

(trans (dge 3 2 [1 2 3 4 5 6]))
=&gt; #&lt;GeneralMatrix| double, ROW, mxn: 2x3, ld:3&gt;((1.0 2.0 3.0) (4.0 5.0 6.0))&lt;&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L251">view source</a></div></div><div class="public anchor" id="var-vect.3F"><h3>vect?</h3><div class="usage"><code>(vect? x)</code></div><div class="doc"><pre class="plaintext">Returns true if x implements uncomplicate.neanderthal.protocols.Vector.

(vect? (dv 1 2 3)) =&gt; true
(vect? [1 2 3]) =&gt; false
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L101">view source</a></div></div><div class="public anchor" id="var-xpy"><h3>xpy</h3><div class="usage"><code>(xpy x y)</code><code>(xpy x y &amp; zs)</code></div><div class="doc"><pre class="plaintext">Sums containers x, y &amp; zs. The result is a new vector instance.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L604">view source</a></div></div><div class="public anchor" id="var-zero"><h3>zero</h3><div class="usage"><code>(zero x)</code></div><div class="doc"><pre class="plaintext">Returns an empty instance of the same type and dimension(s)
as x, which can be vector, matrix or any other neanderthal object.</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/core.clj#L95">view source</a></div></div></div></body></html>