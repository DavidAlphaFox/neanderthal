<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>uncomplicate.neanderthal.real documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Neanderthal 0.2.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>uncomplicate</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>neanderthal</span></div></div></li><li class="depth-3 branch"><a href="uncomplicate.neanderthal.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="uncomplicate.neanderthal.math.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-3 current"><a href="uncomplicate.neanderthal.real.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>real</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-alter.21"><div class="inner"><span>alter!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-asum"><div class="inner"><span>asum</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-ax"><div class="inner"><span>ax</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-axpy"><div class="inner"><span>axpy</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-axpy.21"><div class="inner"><span>axpy!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-dge"><div class="inner"><span>dge</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-dot"><div class="inner"><span>dot</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-dv"><div class="inner"><span>dv</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-entry"><div class="inner"><span>entry</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-fset.21"><div class="inner"><span>fset!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-mm"><div class="inner"><span>mm</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-mm.21"><div class="inner"><span>mm!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-mv"><div class="inner"><span>mv</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-mv.21"><div class="inner"><span>mv!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-nrm2"><div class="inner"><span>nrm2</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-rank"><div class="inner"><span>rank</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-rank.21"><div class="inner"><span>rank!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-real-matrix"><div class="inner"><span>real-matrix</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-real-vector"><div class="inner"><span>real-vector</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-rot.21"><div class="inner"><span>rot!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-scal.21"><div class="inner"><span>scal!</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-sge"><div class="inner"><span>sge</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-sv"><div class="inner"><span>sv</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-to-buffer"><div class="inner"><span>to-buffer</span></div></a></li><li class="depth-1"><a href="uncomplicate.neanderthal.real.html#var-xpy"><div class="inner"><span>xpy</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">uncomplicate.neanderthal.real</h2><div class="doc"><pre class="plaintext">Contains type-specific linear algebraic functions. Typically,
you would want to require this namespace if you need to compute
real matrices containing doubles and/or floats.
Aditionally, you need to require core namespace to use
type-agnostic functions.
You need to take care to only use vectors and matrices
of the same type in the same function call. These functions do not support
arguments of mixed real types. For example, you can not call the
dot function with one double vector (dv) and one float vector (fv).

----- Example
(ns test
  (:require [uncomplicate.neanderthal core real]))
</pre></div><div class="public anchor" id="var-alter.21"><h3>alter!</h3><div class="usage"><code>(alter!)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L234">view source</a></div></div><div class="public anchor" id="var-asum"><h3>asum</h3><div class="usage"><code>(asum x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Sum absolute values.
Sums absolute values of entries of vector x.
(asum (dv -1 2 -3)) =&gt; 6.0</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L260">view source</a></div></div><div class="public anchor" id="var-ax"><h3>ax</h3><div class="usage"><code>(ax alpha x)</code></div><div class="doc"><pre class="plaintext">Multiplies vector x by a scalar a.
Similar to scal!, but does not change x. The result
is a new vector instance.</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L372">view source</a></div></div><div class="public anchor" id="var-axpy"><h3>axpy</h3><div class="usage"><code>(axpy x y)</code><code>(axpy x y &amp; zs)</code></div><div class="doc"><pre class="plaintext">A pure variant of axpy! that does not change
any of the arguments. The result is a new vector instance.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L358">view source</a></div></div><div class="public anchor" id="var-axpy.21"><h3>axpy!</h3><div class="usage"><code>(axpy! y alpha x)</code><code>(axpy! y x)</code><code>(axpy! y x z &amp; zs)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Vector scale and add.

Computes y = ax + y.
where:
x and y are vectors,
a is a scalar.

Multiplies vector x by scalar alpha and adds it to
vector y. After axpy!, y will be changed. The first argument
always have to be the vector in which the result will be put.

If called with 2 arguments, x and y, adds vector x
to vector y.

If called with more than 2 arguments, at least every
other have to be a vector. A scalar multiplier may be
included before each vector.

If the dimensions of x and y are not compatible,
throws IllegalArgumentException.

(def x (dv 1 2 3))
(def y (dv 2 3 4))
(axpy! y 1.5 x)
=&gt; #&lt;DoubleBlockVector| n:3, stride:1, (3.5 6.0 8.5)&gt;

y =&gt; #&lt;DoubleBlockVector| n:3, stride:1, (3.5 6.0 8.5)&gt;

(axpy! y x)
=&gt; #&lt;DoubleBlockVector| n:3, stride:1, (4.5 8.0 11.5)&gt;

(axpy! y x (dv 3 4 5) 2 (dv 1 2 3))
=&gt; #&lt;DoubleBlockVector| n:3, stride:1, (10.5 18.0 25.5)&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L304">view source</a></div></div><div class="public anchor" id="var-dge"><h3>dge</h3><div class="usage"><code>(dge m n source)</code><code>(dge m n)</code></div><div class="doc"><pre class="plaintext">Creates a native-backed, dense, column-oriented
double mxn matrix from source.

If called with two arguments, creates a zero matrix
with dimensions mxn.

Accepts following sources:
- java.nio.ByteBuffer with a capacity = Double/BYTES * m * n,
. which will be used as-is for backing the matrix.
- a clojure sequence, which will be copied into a
. direct ByteBuffer that backs the new vector.

(dge 2 3)
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 2x3, ld:2, ((0.0 0.0) (0.0 0.0) (0.0 0.0))&gt;

(dge 3 2 (range 6))
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 3x2, ld:3 ((0.0 1.0 2.0) (3.0 4.0 5.0))&gt;

(dge 3 2 (java.nio.ByteBuffer/allocateDirect 48))
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 3x2, ld:3 ((0.0 0.0 0.0) (0.0 0.0 0.0))&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L155">view source</a></div></div><div class="public anchor" id="var-dot"><h3>dot</h3><div class="usage"><code>(dot x y)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Dot product.
Computes the dot product of vectors x and y.
(dot (dv 1 2 3) (dv 1 2 3)) =&gt; 14.0</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L240">view source</a></div></div><div class="public anchor" id="var-dv"><h3>dv</h3><div class="usage"><code>(dv source)</code><code>(dv x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Creates a native-backed double vector from source.

Accepts following source:
- java.nio.ByteBuffer with a capacity divisible by 8,
. which will be used as-is for backing the vector.
- a positive integer, which will be used as a dimension
. of new vector with zeroes as entries.
- a floating point number, which will be the only entry
. in a one-dimensional vector.
- a clojure sequence, which will be copied into a
. direct ByteBuffer that backs the new vector.
- varargs will be treated as a clojure sequence.

(dv (java.nio.ByteBuffer/allocateDirect 16))
=&gt; #&lt;DoubleBlockVector| n:2, stride:1 (0.0 0.0)&gt;

(dv 4)
=&gt; #&lt;DoubleBlockVector| n:4, stride:1 (0.0 0.0 0.0 0.0)&gt;

(dv 12.4)
=&gt; #&lt;DoubleBlockVector| n:1, stride:1 (12.4)&gt;

(dv (range 4))
=&gt; #&lt;DoubleBlockVector| n:4, stride:1 (0.0 1.0 2.0 3.0)&gt;

(dv 1 2 3)
=&gt; #&lt;DoubleBlockVector| n:3, stride:1, (1.0 2.0 3.0)&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L121">view source</a></div></div><div class="public anchor" id="var-entry"><h3>entry</h3><div class="usage"><code>(entry x i)</code><code>(entry m i j)</code></div><div class="doc"><pre class="plaintext">Returns the i-th entry of vector x, or ij-th entry of matrix m.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L210">view source</a></div></div><div class="public anchor" id="var-fset.21"><h3>fset!</h3><div class="usage"><code>(fset! c val)</code><code>(fset! v i val)</code><code>(fset! m i j val)</code></div><div class="doc"><pre class="plaintext">Sets the i-th entry of vector x, or ij-th entry of matrix m,
or all entries if no index is provided,
to value val and returns the vector or matrix.</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L220">view source</a></div></div><div class="public anchor" id="var-mm"><h3>mm</h3><div class="usage"><code>(mm alpha a b)</code><code>(mm a b)</code></div><div class="doc"><pre class="plaintext">A pure version of mm!, that returns the result
in a new matrix instance.
Computes alpha a * b</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L515">view source</a></div></div><div class="public anchor" id="var-mm.21"><h3>mm!</h3><div class="usage"><code>(mm! c alpha a b beta)</code><code>(mm! c a b)</code></div><div class="doc"><pre class="plaintext">BLAS 3: Matrix-matrix multiplication.

Computes c = alpha a * b + beta * c
where:
a, b and c are matrices,
alpha and beta are scalars.

Multiplies matrix a by scalar alpha and then multiplies
the resulting matrix by matrix b. Adds the resulting
matrix to matrix c previously scaled by scalar beta.
Returns matrix c, which contains the result and is changed by
the operation.

Can be called without scalars, with three matrix arguments.

If the dimensions of a, b and c are not compatible,
throws IllegalArgumentException.

(def a (dge 2 3 (range 6)))
(def a (dge 3 2 (range 2 8)))
(def c (dge 2 2 [1 1 1 1]))

(mm! c 1.5 a b 2.5)
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 2x2, ld:2, ((35.5 49.0) (62.5 89.5))&gt;

(def c (dge 2 2))
(mm! c a b)
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 2x2, ld:2, ((22.0 31.0) (40.0 58.0))&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L472">view source</a></div></div><div class="public anchor" id="var-mv"><h3>mv</h3><div class="usage"><code>(mv alpha a x)</code><code>(mv a x)</code></div><div class="doc"><pre class="plaintext">A pure version of mv! that returns the result
in a new vector instance. Computes alpha a * x.</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L429">view source</a></div></div><div class="public anchor" id="var-mv.21"><h3>mv!</h3><div class="usage"><code>(mv! y alpha a x beta)</code><code>(mv! y alpha a x)</code><code>(mv! y a x)</code></div><div class="doc"><pre class="plaintext">BLAS 2: Matrix-vector multiplication.

Computes y = alpha a * x + beta * y
where:
a is a matrix,
x and y are vectors,
alpha and beta are scalars.

Multiplies matrix a by scalar alpha and then multiplies
the the resulting matrix by vector x. Adds the resulting
vector to vector y previously scaled by scalar beta.
Returns vector y, which contains the result and is changed by
the operation.

If alpha and beta are not provided, uses 1.0 as their values.

If the dimensions of a, x and y are not compatible,
throws IllegalArgumentException.

(def a (dge 3 2 (range 6)))
(def x (dv 1 2))
(def y (dv 2 3 4))

(mv! y 2.0 a x 1.5)
=&gt; #&lt;DoubleBlockVector| n:3, stride:1, (15.0 22.5 30.0)&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L390">view source</a></div></div><div class="public anchor" id="var-nrm2"><h3>nrm2</h3><div class="usage"><code>(nrm2 x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Euclidean norm.
Computes the Euclidan (L2) norm of vector x.
(nrm2 (dv 1 2 3)) =&gt; 3.7416573867739413</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L252">view source</a></div></div><div class="public anchor" id="var-rank"><h3>rank</h3><div class="usage"><code>(rank alpha x y)</code><code>(rank x y)</code></div><div class="doc"><pre class="plaintext">A pure version of rank! that returns the result
in a new matrix instance.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L462">view source</a></div></div><div class="public anchor" id="var-rank.21"><h3>rank!</h3><div class="usage"><code>(rank! a alpha x y)</code><code>(rank! a x y)</code></div><div class="doc"><pre class="plaintext">BLAS 2: General rank-1 update.

Computes a = a + alpha * x * y&apos;
where:
a is a mxn matrix,
x and y are vectors, y&apos; is a transposed vector,
a is a scalar.

If called with 3 arguments, a, x, y, alpha is 1.0.

(def a (dge 3 2 [1 1 1 1 1 1]))
(rank! a 1.5 (dv 1 2 3) (dv 4 5))
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 3x2, ld:3, ((7.0 13.0 19.0) (8.5 16.0 23.5))&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L437">view source</a></div></div><div class="public anchor" id="var-real-matrix"><h3>real-matrix</h3><div class="usage"><code>(real-matrix bytesize m n source)</code><code>(real-matrix bytesize m n)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L66">view source</a></div></div><div class="public anchor" id="var-real-vector"><h3>real-vector</h3><div class="usage"><code>(real-vector bytesize source)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L49">view source</a></div></div><div class="public anchor" id="var-rot.21"><h3>rot!</h3><div class="usage"><code>(rot! x y c s)</code><code>(rot! x y c)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Apply plane rotation.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L268">view source</a></div></div><div class="public anchor" id="var-scal.21"><h3>scal!</h3><div class="usage"><code>(scal! alpha x)</code></div><div class="doc"><pre class="plaintext">BLAS 1: Scale vector.

Computes x = ax
where:
- x is a vector,
- a is a scalar.

Multiplies vector x by scalar alpha, i.e scales the vector.
After scal!, x will be changed.

(scal! 1.5  (dv 1 2 3))
=&gt; #&lt;DoubleBlockVector| n:3, stride:1, (1.5 3.0 4.5)&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L287">view source</a></div></div><div class="public anchor" id="var-sge"><h3>sge</h3><div class="usage"><code>(sge m n source)</code><code>(sge m n)</code></div><div class="doc"><pre class="plaintext">Creates a native-backed, dense, column-oriented
float mxn matrix from source.

If called with two arguments, creates a zero matrix
with dimensions mxn.

Accepts following sources:
- java.nio.ByteBuffer with a capacity = Float/BYTES * m * n,
. which will be used as-is for backing the matrix.
- a clojure sequence, which will be copied into a
. direct ByteBuffer that backs the new vector.

(sge 2 3)
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 2x3, ld:2, ((0.0 0.0) (0.0 0.0) (0.0 0.0))&gt;

(sge 3 2 (range 6))
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 3x2, ld:3 ((0.0 1.0 2.0) (3.0 4.0 5.0))&gt;

(sge 3 2 (java.nio.ByteBuffer/allocateDirect 48))
=&gt; #&lt;DoubleGeneralMatrix| COL, mxn: 3x2, ld:3 ((0.0 0.0 0.0) (0.0 0.0 0.0))&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L182">view source</a></div></div><div class="public anchor" id="var-sv"><h3>sv</h3><div class="usage"><code>(sv source)</code><code>(sv x &amp; xs)</code></div><div class="doc"><pre class="plaintext">Creates a native-backed float vector from source.

Accepts following source:
- java.nio.ByteBuffer with a capacity divisible by 4,
. which will be used as-is for backing the vector.
- a positive integer, which will be used as a dimension
. of new vector with zeroes as entries.
- a floating point number, which will be the only entry
. in a one-dimensional vector.
- a clojure sequence, which will be copied into a
. direct ByteBuffer that backs the new vector.
- varargs will be treated as a clojure sequence.

(sv (java.nio.ByteBuffer/allocateDirect 16))
=&gt; #&lt;FloatBlockVector| n:4, stride:1 (0.0 0.0 0.0 0.0)&gt;

(sv 4)
=&gt; #&lt;FloatBlockVector| n:4, stride:1 (0.0 0.0 0.0 0.0)&gt;

(sv 12.4)
=&gt; #&lt;FloatBlockVector| n:1, stride:1 (12.4)&gt;

(sv (range 4))
=&gt; #&lt;FloatBlockVector| n:4, stride:1 (0.0 1.0 2.0 3.0)&gt;

(sv 1 2 3)
=&gt; #&lt;FloatBlockVector| n:3, stride:1, (1.0 2.0 3.0)&gt;
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L87">view source</a></div></div><div class="public anchor" id="var-to-buffer"><h3>to-buffer</h3><div class="usage"><code>(to-buffer bytesize s)</code><code>(to-buffer s)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L39">view source</a></div></div><div class="public anchor" id="var-xpy"><h3>xpy</h3><div class="usage"><code>(xpy x y)</code><code>(xpy x y &amp; zs)</code></div><div class="doc"><pre class="plaintext">Sums vectors x, y, &amp; zs. The result is a new vector instance.
</pre></div><div class="src-link"><a href="http://github.com/uncomplicate/neanderthal/blob/master/src/clojure/uncomplicate/neanderthal/real.clj#L379">view source</a></div></div></div></body></html>